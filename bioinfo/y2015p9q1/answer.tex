\input{../../template.tex}

\begin{document}
\begin{enumerate}[label=(\alph*)]
  \item

    The LCS problem is the problem of finding the longest sequence $s$ that is a subsequence of two strings $s_1$ and $s_2$, where subsequence is defined by any sequence of characters generated by removing any number of characters in the original string.

    To solve the given problem, we proceed by generating the edit graph:

    \begin{tabular}{c|c|c|c|c|c}
      &$\varepsilon$&A&C&G&T\\
      \hline
      $\varepsilon$&0&0&0&0&0\\
      \hline
      G&0&0&0&1&1\\
      \hline
      G&0&0&0&1&1\\
      \hline
      T&0&0&0&1&2\\
      \hline
      T&0&0&0&1&2\\
      \hline
      T&0&0&0&1&2\\
      \hline
      A&0&1&1&1&2\\
      \hline
      A&0&1&1&1&2\\
      \hline
      G&0&1&1&2&2\\
      \hline
      C&0&1&2&2&2\\
      \hline
      C&0&1&2&2&2\\
      \hline
      G&0&1&2&3&3\\
      \hline
      T&0&1&2&3&4\\
        
    \end{tabular}

    Then, we backtrack from the bottom-right corner, adding a character whenever we see a match (diagonal move up left):

    \texttt{ACGT}

  \item
    The Nussinov algorithm is an algorithm for predicting RNA structure from a given RNA sequence. It is a dynamic programming algorithm that works by considering three different cases for how RNA might interact (left-sided mismatch, right-sided mismatch, pairing, and bifurcation).

    It has three main limitations:

    \begin{itemize}
      \item
        It does not predict any of the 3D structure of the RNA, only 2D.

      \item
        It cannot predict RNA pseudo-knots, because one base interacts with more than 1 other base, which the Nussinov algorithm cannot account for.

      \item
        It does not account for minimum stem loop size.
    \end{itemize}

  \item
    To cluster sequence datasets, I would use a phylogenetic algorithm like neighbour-joining or maximum parsimony. This is because these algorithms are designed around taking into account intricacies of sequence data, like calculating distance between two sequences.

    To cluster gene expression datasets, I would use something like the $k$-means algorithm, since we can represent gene expression datasets as a set of $n$-dimensional points, which is exactly what the $k$-means clustering algorithm works on.

  \item
    The Markov Clustering algorithm iterates a series of steps repeatedly.

    In particular, the steps are to expand a matrix (by raising it to a power, usually 2), and then inflating the matrix, which involves summing over a row. The expansion is matrix multiplication, so for an $n \times n$ matrix, this takes $O(n^3)$ time. The inflation takes $O(n^2)$ time because computing the sums takes $O(n^2)$ time, and then calculating each matrix element is another $O(n^2)$ time.

    So, one iteration takes $O(n^3)$ time overall.

    However, the number of iterations to reach convergence is not known, although it is usually in the range of 10-100, so we could consider the entire algorithm to be $O(n^3)$ (with a big constant).

  \item
    The Gillespie algorithm makes the following assumptions:

    \begin{itemize}
      \item
        Reactions happen serially, and never in parallel (made realistic by making timesteps extremely small)

      \item
        The mixture of molecules must be well stirred, so each molecule is uniformly distributed amongst the mixture.

      \item
        Reactions happen only between two molecules (between three can be modelled by two binary reactions if necessary).
    \end{itemize}

    The Gillespie algorithm works by randomly selecting a timestep, based on the propensity of any reaction occurring, and then randomly choosing a reaction to occur (based on the proportions of molecules at any point), and making that reaction occur until the next timestep. This is then iterated repeatedly.

    Since we run this for an independent number of iterations, we consider only the complexity for a single iteration. For a single iteration, we have to generate propensities of each reaction, which takes $O(N)$ time with $N$ different reactions.
        
\end{enumerate}
\end{document}
