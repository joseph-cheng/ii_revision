\input{../../template.tex}

\begin{document}
\begin{enumerate}[label=(\alph*)]
  \item
    To be reasonably confident that an amino acid multiple sequence alignment is optimal, we can use an amino acid scoring matrix. For example, this matrix could represent the probability that a particular amino acid could be replaced by another particular amino acid. Using this matrix, we can calculate the `score' of a particular multiple alignment by calculating the entropy of each column (by summing the surprisal of each pairwise alignment for that column), and then summing the entropies of each column. The higher the entropy, the worse the matrix. Then, we can slightly perturb our alignment in different ways, to obtain variations of our alignment. We can calculate the score of each of these, and see if any are better than our original alignment.

    This does not guarantee that we determine optimality, since we could mistake a local maxima as a global maxima, but there is no fast, reliable way to determine if we are in a global maxima or else we would not have to use heuristic solutions for the multiple sequence alignment problem in the first place.

  \item

    Local alignment might have potential, but because we do not know the start positions of the motif in each of the DNA sequences it is hard to use.

    A better way of finding a shared motif is to use Gibbs sampling, which works by randomly guessing where the motif begins in each DNA sequence, and attempting to update the position of the motif in each DNA sequence by weighting by likelihood based on the probability distribution generated by considering the other DNA sequence's guessed motifs.

    After this is done, we have identified similar motifs in each of the DNA sequences, which we can extract. To cluster these motifs by similarity, we can use sequence alignment to generate distances between each of the sequences, and then run a tree-generating algorithm like neighbour-joining or UPGMA. For example, for UPGMA, we first give each animal its own cluster, and then iteratively join together clusters based on the average distance between each animal in the clusters.

    This gives us a phylogenetic tree, from which we can generate clusters by cutting off the tree at some point, for example.

  \item
    First, since the genomes are very long, when we store them we would likely want to use an algorithm like the Burrows-Wheeler Transform, which makes the data more amenable to run-length encoding. 

    Once we have the actual genome in memory, we can generate constructs like a de Bruijn graph of the genome. This would help us find the location of short reads in our genome, for example if we wanted to find the location of a short gene in our genome.

    If we wanted to perform larger alignments, then we might want to use the Smith Waterman algorithm for local alignment, since it is unlikely that we care about global alignment for entire genomes.

    Finally, if we wanted to align many genomes, then we could use progressive alignment to give us a multiple alignment.

        
\end{enumerate}
\end{document}
