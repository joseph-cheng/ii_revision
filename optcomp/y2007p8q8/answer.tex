\input{../../template.tex}

\begin{document}
\begin{enumerate}[label=(\alph*)]

  \item

    CSE uses available expression analysis. The idea behind it is that when an expression is evaluated, but has already been previously evaluated, we should use the value calculated earlier, instead of re-calculating it.

    Available expression analysis is a dataflow analysis that tells us what expressions are syntactically available at a particular node, where syntactically available means that it is computed on every previous path from a node.

    It uses the two following data-flow equations:

    \[
      in-avail(n) = \begin{cases}\{\} & pred(n) = \emptyset\\\bigcap_{p \in pred(n)} out-avail(p)&\text{otherwise}\end{cases}
    .\] 

    \[
      out-avail(n) = in-avail(n) \setminus kill(n) \cup gen(n)
    .\] 

    Where $kill(n)$ is the set of expressions killed by $n$ (those that have a variable they use assigned to by $n$), and $n$ is the set of expressions generated by $n$ (those that it computes).

    Then, we combine these two into the equation:

    \[
      avail(n) = \begin{cases}\{\}&pred(n) = \emptyset\\\bigcap_{p \in pred(n)} \left(avail(p) \setminus kill(p) \cup gen(p)\right)&\text{otherwise}\end{cases}
    .\] 

    These can then be computed by an algorithm like the one that follows:

\begin{verbatim}
avail[0] = {}
for i in 1..N
  avail[i] = U

while (avail[] changes)
  for i in 1..N
    avail[i] = big_intersect(p in pred(n), avail[p] \ kill(p) U gen(p))
\end{verbatim}

To use these solutions, we find where a node $n$ has an available expression, say it is instruction $x := a \oplus b$, and replace it with $x := t$. Then, we iterate backwards from $n$ on every path to find the first time that $a \oplus b$ is calculated on each path, say there is instruction $y := a \oplus b$. We replace it with $t := a \oplus b;y := t$.

It should be noted that this generates a lot of MOV instructions, which we would expect to be cleaned up by a future optimisation stage, like copy propagation.

\item
  \begin{enumerate}[label=(\roman*)]

    \item
      Since $P$ is in SSA form, we know that no assignments to $A$ or $B$ occur in unspecified instructions 3 to 5 (or else it wouldn't be in SSA form). Therefore, we could move instruction 6 to any location after instruction 2 (or else $A$ and $B$ would not have values), and before instruction 7 (or else $C$ and $D$ would not have a variable to take the value of $A+B$ from). We know that this will not change the behaviour of our program because $A$ and $B$ are not modified in instructions 3 to 5.

    \item
      Here, $A$ is live from instruction 1 to instruction 6.

      $B$ is live from instruction 2 to instruction 6.

      $C$ is live from instruction 7 to instruction 9.

      $D$ is live from instruction 8 to instruction 9.

      $Z$ is live from instruction 6 to instruction 8.

      So, the total heuristic is $5 + 4 + 2 + 1 + 2 = 14$.

      For program $Q$, we simply extend the live ranges of $A$ and $B$ to instruction 10 instead, so we add an additional $2 \cdot 4 = 8$ on to our heuristic, for a total of 22.

    \item
      By moving $Z$ upwards one instruction, we increase the live range of $Z$ by 1, and decrease the live ranges of $A$ and $B$ by 1 each for program $P$, and not at all for program $Q$.

      So for $P$, the best position for $Z$ is instruction 3, as high as it can go, leading to a total heuristic of $2 + 1 + 2 + 1 + 5 = 11$.

      For $Q$, the best position for $Z$ is as far down as it can go (instruction 6), leading to a total heuristic of 22, as before.

      Therefore, we see that the best position for $Z$ is as early as possible if its parameters are not live after the instruction, and as late as possible if its parameters are still live after the instruction (if just one is live, it does not matter where we put it). Therefore, we can refine (a) by introducing live variable analysis and moving our assignment to the temporary appropriately, as described.

      
  \end{enumerate}

        
    \end{enumerate}
\end{document}
